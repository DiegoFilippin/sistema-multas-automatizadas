import React, { useState, useEffect } from 'react';
import { Upload, FileText, MessageCircle, Eye, User, MapPin, Hash } from 'lucide-react';
import { toast } from 'sonner';
import { useSearchParams } from 'react-router-dom';
import FileUpload from '../components/FileUpload';
import DataExtraction from '../components/DataExtraction';
import RecursoPreview from '../components/RecursoPreview';
import GeminiOcrService from '../services/geminiOcrService';
import { multasService } from '../services/multasService';
import { chatService } from '../services/chatService';
import { multaLeveService, type MultaLeveAnalysis } from '../services/multaLeveService';
import AdvertenciaEscrita from '../components/AdvertenciaEscrita';
import recursosGeradosService, { type RecursoGeradoInsert } from '../services/recursosGeradosService';
import RecursosGerados from '../components/RecursosGerados';

// Fun√ß√£o auxiliar para gerar UUIDs v√°lidos
const generateValidUUID = (): string => {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  // Fallback para gerar UUID v4 manualmente
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
};

// Fun√ß√£o auxiliar para validar e obter UUID v√°lido
const getValidUUID = (value: string | undefined | null, fallbackLabel: string): string => {
  if (value && value !== 'client-id-placeholder' && value !== 'company-id-placeholder' && value !== 'user-id-placeholder') {
    // Validar se √© um UUID v√°lido (formato b√°sico)
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    if (uuidRegex.test(value)) {
      console.log(`‚úÖ UUID v√°lido encontrado para ${fallbackLabel}:`, value);
      return value;
    }
  }
  
  const newUUID = generateValidUUID();
  console.log(`üÜî UUID gerado para ${fallbackLabel}:`, newUUID);
  return newUUID;
};

// Fun√ß√£o para buscar um company_id existente no banco
const getExistingCompanyId = async (): Promise<string | null> => {
  try {
    console.log('üîç Buscando company_id existente no banco...');
    
    // Importar supabase client
    const { supabase } = await import('../lib/supabase');
    
    const { data: companies, error } = await supabase
      .from('companies')
      .select('id')
      .eq('status', 'ativo')
      .limit(1);
    
    if (error) {
      console.error('‚ùå Erro ao buscar companies:', error);
      // Criar company de teste se n√£o existir
      return await createTestCompany();
    }
    
    if (companies && companies.length > 0) {
      const companyId = companies[0].id;
      console.log('‚úÖ Company_id existente encontrado:', companyId);
      return companyId;
    }
    
    console.log('‚ö†Ô∏è Nenhuma company encontrada no banco, criando uma de teste...');
    return await createTestCompany();
    
  } catch (error: any) {
    console.error('‚ùå Erro ao buscar company_id existente:', error);
    return await createTestCompany();
  }
};

// Fun√ß√£o para buscar um client_id existente no banco
const getExistingClientId = async (): Promise<string | null> => {
  try {
    console.log('üîç Buscando client_id existente no banco...');
    
    // Importar supabase client
    const { supabase } = await import('../lib/supabase');
    
    const { data: clients, error } = await supabase
      .from('clients')
      .select('id')
      .eq('status', 'ativo')
      .limit(1);
    
    if (error) {
      console.error('‚ùå Erro ao buscar clients:', error);
      // Tentar criar client de teste
      const companyId = await getExistingCompanyId();
      if (companyId) {
        return await createTestClient(companyId);
      }
      return null;
    }
    
    if (clients && clients.length > 0) {
      const clientId = clients[0].id;
      console.log('‚úÖ Client_id existente encontrado:', clientId);
      return clientId;
    }
    
    console.log('‚ö†Ô∏è Nenhum client encontrado no banco, criando um de teste...');
    const companyId = await getExistingCompanyId();
    if (companyId) {
      return await createTestClient(companyId);
    }
    return null;
    
  } catch (error: any) {
    console.error('‚ùå Erro ao buscar client_id existente:', error);
    return null;
  }
};

// Fun√ß√£o para criar uma company de teste
const createTestCompany = async (): Promise<string | null> => {
  try {
    console.log('üÜï Criando company de teste...');
    
    const { supabase } = await import('../lib/supabase');
    
    // Primeiro, verificar se existe companies_master
    const { data: masterCompanies } = await supabase
      .from('companies_master')
      .select('id')
      .limit(1);
    
    let masterCompanyId = masterCompanies?.[0]?.id;
    
    if (!masterCompanyId) {
      // Criar companies_master se n√£o existir
      const { data: newMaster, error: masterError } = await supabase
        .from('companies_master')
        .insert({
          nome: 'Empresa Master Teste',
          email: 'master@teste.com',
          telefone: '(11) 99999-9999',
          endereco: 'Endere√ßo Master Teste'
        })
        .select('id')
        .single();
      
      if (masterError) {
        console.error('‚ùå Erro ao criar companies_master:', masterError);
        return generateValidUUID(); // Fallback para UUID gerado
      }
      
      masterCompanyId = newMaster.id;
    }
    
    // Verificar se existe plano
    const { data: plans } = await supabase
      .from('plans')
      .select('id')
      .limit(1);
    
    let planId = plans?.[0]?.id;
    
    if (!planId) {
      // Usar um UUID padr√£o para plano se n√£o existir
      planId = generateValidUUID();
    }
    
    // Criar company
    const { data: newCompany, error: companyError } = await supabase
      .from('companies')
      .insert({
        master_company_id: masterCompanyId,
        plan_id: planId,
        nome: 'Empresa Teste LTDA',
        cnpj: '12.345.678/0001-90',
        email: 'empresa@teste.com',
        telefone: '(11) 88888-8888',
        endereco: 'Rua Teste, 123',
        data_inicio_assinatura: new Date().toISOString()
      })
      .select('id')
      .single();
    
    if (companyError) {
      console.error('‚ùå Erro ao criar company:', companyError);
      return generateValidUUID(); // Fallback para UUID gerado
    }
    
    console.log('‚úÖ Company de teste criada:', newCompany.id);
    return newCompany.id;
    
  } catch (error: any) {
    console.error('‚ùå Erro ao criar company de teste:', error);
    return generateValidUUID(); // Fallback para UUID gerado
  }
};

// Fun√ß√£o para criar um client de teste
const createTestClient = async (companyId: string): Promise<string | null> => {
  try {
    console.log('üÜï Criando client de teste...');
    
    const { supabase } = await import('../lib/supabase');
    
    const { data: newClient, error } = await supabase
      .from('clients')
      .insert({
        company_id: companyId,
        nome: 'Cliente Teste',
        cpf_cnpj: '123.456.789-00',
        email: 'cliente@teste.com',
        telefone: '(11) 77777-7777',
        endereco: 'Rua Cliente, 456',
        cidade: 'S√£o Paulo',
        estado: 'SP',
        cep: '01234-567'
      })
      .select('id')
      .single();
    
    if (error) {
      console.error('‚ùå Erro ao criar client:', error);
      return generateValidUUID(); // Fallback para UUID gerado
    }
    
    console.log('‚úÖ Client de teste criado:', newClient.id);
    return newClient.id;
    
  } catch (error: any) {
    console.error('‚ùå Erro ao criar client de teste:', error);
    return generateValidUUID(); // Fallback para UUID gerado
  }
};

// Fun√ß√£o para criar um cliente padr√£o se necess√°rio
const createDefaultClient = async (companyId: string, clienteInfo: any): Promise<string | null> => {
  try {
    console.log('üÜï Criando cliente padr√£o...');
    
    // Importar supabase client
    const { supabase } = await import('../lib/supabase');
    
    // Usar dados do clienteInfo se dispon√≠vel, sen√£o usar dados padr√£o
    const newClientData = {
      nome: clienteInfo?.nome || 'Cliente Padr√£o',
      cpf_cnpj: clienteInfo?.cpf_cnpj || '00000000000',
      email: clienteInfo?.email || 'cliente@exemplo.com',
      telefone: clienteInfo?.telefone || '(00) 00000-0000',
      endereco: clienteInfo?.endereco || 'Endere√ßo n√£o informado',
      cidade: clienteInfo?.cidade || 'Cidade n√£o informada',
      estado: clienteInfo?.estado || 'SP',
      cep: clienteInfo?.cep || '00000-000',
      company_id: companyId,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

  // Fun√ß√£o para fazer polling da resposta do n8n
  const pollForN8nResponse = async (webhookData: any, type: 'initial' | 'message', maxAttempts: number = 10) => {
    console.log(`üîÑ === INICIANDO POLLING PARA RESPOSTA N8N (${type.toUpperCase()}) ===`);
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        console.log(`üîÑ Tentativa ${attempt}/${maxAttempts} - Aguardando resposta...`);
        
        // Aguardar um tempo antes de cada tentativa
        await new Promise(resolve => setTimeout(resolve, 2000 * attempt)); // Aumentar o tempo a cada tentativa
        
        // Fazer nova requisi√ß√£o para verificar se h√° resposta
        const response = await fetch('https://webhookn8n.synsoft.com.br/webhook/853f7024-bfd2-4c18-96d2-b98b697c87c4', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            ...webhookData,
            action: 'check_response', // Indicar que √© uma verifica√ß√£o
            attempt: attempt
          })
        });
        
        if (!response.ok) {
          console.warn(`‚ö†Ô∏è Tentativa ${attempt} falhou:`, response.status);
          continue;
        }
        
        const webhookResponse = await response.json();
        console.log(`üìã Resposta da tentativa ${attempt}:`, webhookResponse);
        
        // Verificar se recebemos uma resposta real (n√£o apenas "Workflow was started")
        const isRealResponse = webhookResponse?.message !== 'Workflow was started' && 
                              (Array.isArray(webhookResponse) || 
                               (webhookResponse?.response && webhookResponse.response.length > 50));
        
        if (isRealResponse) {
          console.log(`‚úÖ === RESPOSTA REAL RECEBIDA NA TENTATIVA ${attempt} ===`);
          
          // Processar resposta real
          let responseContent = '';
          if (Array.isArray(webhookResponse) && webhookResponse.length > 0) {
            const firstItem = webhookResponse[0];
            responseContent = firstItem.response || firstItem.message || JSON.stringify(firstItem);
          } else if (webhookResponse?.response) {
            responseContent = webhookResponse.response;
          } else {
            responseContent = JSON.stringify(webhookResponse);
          }
          
          // Atualizar o chat com a resposta real
          if (type === 'initial') {
            // Atualizar mensagem inicial
            setN8nChatMessages(prev => {
              const updated = [...prev];
              if (updated.length > 1) {
                updated[1] = {
                  ...updated[1],
                  content: responseContent,
                  timestamp: new Date()
                };
              }
              return updated;
            });
          } else {
            // Adicionar nova mensagem para mensagens subsequentes
            const aiMessage: ChatMessage = {
              id: `n8n_ai_${Date.now()}`,
              type: 'ai',
              content: responseContent,
              timestamp: new Date()
            };
            setN8nChatMessages(prev => [...prev, aiMessage]);
          }
          
          // Salvar no banco de dados se temos sess√£o ativa
          if (chatSessionId) {
            try {
              await chatService.addMessage({
                chatSessionId: chatSessionId,
                messageType: 'assistant',
                content: responseContent,
                metadata: { 
                  source: `n8n_polling_${type}`,
                  attempt: attempt,
                  webhookResponse: webhookResponse,
                  timestamp: new Date().toISOString()
                }
              });
              
              console.log(`‚úÖ Resposta do polling salva no banco (tentativa ${attempt})`);
              
              // Detectar e salvar recurso se presente
              if (multaId) {
                try {
                  const recursoDetectado = await detectarESalvarRecurso(responseContent, chatSessionId, multaId);
                  if (recursoDetectado) {
                    console.log('‚úÖ Recurso detectado no polling:', recursoDetectado.id);
                    toast.success('üéØ Resposta da IA recebida e recurso detectado!');
                  } else {
                    toast.success('‚úÖ Resposta da IA recebida!');
                  }
                } catch (recursoError: any) {
                  console.error('‚ùå Erro ao detectar recurso no polling:', recursoError);
                  toast.success('‚úÖ Resposta da IA recebida!');
                }
              } else {
                toast.success('‚úÖ Resposta da IA recebida!');
              }
              
            } catch (saveError: any) {
              console.warn('‚ö†Ô∏è Erro ao salvar resposta do polling:', saveError);
              toast.success('‚úÖ Resposta da IA recebida!');
            }
          }
          
          return; // Sucesso, sair do loop
        }
        
      } catch (error: any) {
        console.warn(`‚ö†Ô∏è Erro na tentativa ${attempt}:`, error.message);
      }
    }
    
    // Se chegou aqui, todas as tentativas falharam
    console.warn(`‚ùå Polling falhou ap√≥s ${maxAttempts} tentativas`);
    toast.warning('‚è≥ O sistema est√° processando sua solicita√ß√£o. A resposta pode demorar alguns minutos.');
  };

  // Fun√ß√£o para detectar e salvar recursos gerados pelo n8n
  const detectarESalvarRecurso = async (responseContent: string, chatSessionId: string, multaId: string) => {
    try {
      // Verificar se a resposta cont√©m um recurso (indicadores comuns)
      const indicadoresRecurso = [
        'RECURSO',
        'DEFESA',
        'EXCELENT√çSSIMO',
        'PEDIDO',
        'FUNDAMENTA√á√ÉO',
        'REQUER',
        'DEFERIMENTO',
        'ANULA√á√ÉO',
        'AUTO DE INFRA√á√ÉO'
      ];
      
      const contemRecurso = indicadoresRecurso.some(indicador => 
        responseContent.toUpperCase().includes(indicador)
      );
      
      // Verificar se tem estrutura de recurso (mais de 200 caracteres e cont√©m indicadores)
      const isRecurso = contemRecurso && responseContent.length > 200;
      
      if (isRecurso) {
        console.log('üéØ === RECURSO DETECTADO NA RESPOSTA N8N ===');
        console.log('üìù Conte√∫do:', responseContent.substring(0, 200) + '...');
        
        // Extrair informa√ß√µes do recurso
        const infoRecurso = recursosGeradosService.extrairInformacoesRecurso(responseContent);
        console.log('üìã Informa√ß√µes extra√≠das:', infoRecurso);
        
        // Obter dados do usu√°rio e empresa
        const companyId = await getExistingCompanyId() || getValidUUID(clienteData?.cliente_id, 'Company ID (recurso)');
        const userId = getValidUUID(clienteData?.cliente_id, 'User ID (recurso)');
        
        // Preparar dados para salvamento
        const recursoData: RecursoGeradoInsert = {
          company_id: companyId,
          user_id: userId,
          multa_id: multaId,
          chat_session_id: chatSessionId,
          titulo: infoRecurso.titulo,
          conteudo_recurso: infoRecurso.conteudo,
          fundamentacao_legal: infoRecurso.fundamentacao,
          argumentos_principais: infoRecurso.argumentos,
          tipo_recurso: infoRecurso.tipo,
          status: 'gerado',
          metadata: {
            source: 'n8n_webhook',
            detectedAt: new Date().toISOString(),
            multaData: multaData,
            clienteData: clienteData
          }
        };
        
        console.log('üíæ Salvando recurso gerado:', recursoData);
        
        // Salvar no banco de dados
        const recursoSalvo = await recursosGeradosService.salvarRecurso(recursoData);
        
        if (recursoSalvo) {
          console.log('‚úÖ Recurso salvo com sucesso:', recursoSalvo.id);
          
          // Atualizar lista de recursos gerados
          setRecursosGerados(prev => [recursoSalvo, ...prev]);
          
          // Mostrar notifica√ß√£o de sucesso
          toast.success('üéâ Recurso detectado e salvo automaticamente!');
          
          return recursoSalvo;
        }
      } else {
        console.log('‚ÑπÔ∏è Resposta n√£o cont√©m recurso detect√°vel');
      }
      
      return null;
    } catch (error: any) {
      console.error('‚ùå Erro ao detectar/salvar recurso:', error);
      toast.error('Erro ao salvar recurso detectado: ' + error.message);
      return null;
    }
  };
    
    console.log('üìã Dados do cliente padr√£o a ser criado:', newClientData);
    
    const { data: newClient, error } = await supabase
      .from('clients')
      .insert([newClientData])
      .select('id')
      .single();
    
    if (error) {
      console.error('‚ùå Erro ao criar cliente padr√£o:', error);
      return null;
    }
    
    console.log('‚úÖ Cliente padr√£o criado com ID:', newClient.id);
    return newClient.id;
    
  } catch (error: any) {
    console.error('‚ùå Erro ao criar cliente padr√£o:', error);
    return null;
  }
};

interface MultaData {
  // Dados b√°sicos
  numero?: string;
  infracao?: string;
  codigoInfracao?: string;
  local?: string;
  data?: string;
  valor?: string;
  veiculo?: string;
  condutor?: string;
  orgaoAutuador?: string;
  pontos?: string;
  observacoes?: string;
  
  // Dados do equipamento
  numeroEquipamento?: string;
  tipoEquipamento?: string;
  localizacaoEquipamento?: string;
  velocidadePermitida?: string;
  velocidadeAferida?: string;
  
  // Dados do propriet√°rio
  nomeProprietario?: string;
  cpfCnpjProprietario?: string;
  enderecoProprietario?: string;
  
  // Observa√ß√µes detalhadas
  observacoesGerais?: string;
  observacoesCondutor?: string;
  observacoesVeiculo?: string;
  mensagemSenatran?: string;
  
  // Registro fotogr√°fico
  transcricaoRegistroFotografico?: string;
  motivoNaoAbordagem?: string;
  
  // Dados do equipamento e notifica√ß√£o
  dadosEquipamento?: string;
  notificacaoAutuacao?: string;
}

interface ChatMessage {
  id: string;
  type: 'user' | 'ai';
  content: string;
  timestamp: Date;
}

const TesteRecursoIA: React.FC = () => {
  const [searchParams] = useSearchParams();
  const [currentStep, setCurrentStep] = useState<'upload' | 'extraction' | 'recurso'>('upload');
  const [uploadedFile, setUploadedFile] = useState<File | null>(null);
  const [multaData, setMultaData] = useState<MultaData>({});
  const [recursoText, setRecursoText] = useState<string>('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [chatSessionId, setChatSessionId] = useState<string | null>(null);
  const [multaId, setMultaId] = useState<string | null>(null);
  const [n8nChatMessages, setN8nChatMessages] = useState<ChatMessage[]>([]);
  const [n8nChatActive, setN8nChatActive] = useState(false);
  const [n8nInputValue, setN8nInputValue] = useState('');
  const [isN8nLoading, setIsN8nLoading] = useState(false);
  const [isProcessLocked, setIsProcessLocked] = useState(false);
  const [processId, setProcessId] = useState<string | null>(null);
  const [clienteData, setClienteData] = useState<{
    nome: string;
    cpf_cnpj: string;
    endereco: string;
    email: string;
    telefone: string;
    payment_id: string;
    amount_paid: string;
    multa_type: string;
    service_order_id?: string;
    cliente_id?: string;
  } | null>(null);
  
  // Estados para funcionalidade de multa leve
  const [analiseMultaLeve, setAnaliseMultaLeve] = useState<MultaLeveAnalysis | null>(null);
  const [showAdvertencia, setShowAdvertencia] = useState(false);
  
  // Estados para recursos gerados
  const [recursosGerados, setRecursosGerados] = useState<any[]>([]);
  const [showRecursosGerados, setShowRecursosGerados] = useState(false);

  // Carregar hist√≥rico de mensagens do banco quando chatSessionId √© definido
  useEffect(() => {
    const loadChatHistory = async () => {
      if (chatSessionId) {
        try {
          console.log('üìö === CARREGANDO HIST√ìRICO DO CHAT ===');
          console.log('üÜî Session ID:', chatSessionId);
          
          const messages = await chatService.getMessages(chatSessionId);
          console.log('üìã Mensagens carregadas do banco:', messages);
          
          if (messages && messages.length > 0) {
            // Converter mensagens do banco para o formato do chat
            const chatMessages: ChatMessage[] = messages.map(msg => ({
              id: msg.id,
              type: msg.message_type === 'user' ? 'user' : 'ai',
              content: msg.content,
              timestamp: new Date(msg.created_at)
            }));
            
            console.log('‚úÖ Mensagens convertidas:', chatMessages);
            setN8nChatMessages(chatMessages);
            
            toast.success(`Hist√≥rico carregado: ${messages.length} mensagens recuperadas`);
          } else {
            console.log('‚ÑπÔ∏è Nenhuma mensagem encontrada no hist√≥rico');
          }
        } catch (error: any) {
          console.error('‚ùå Erro ao carregar hist√≥rico do chat:', error);
          toast.error('Erro ao carregar hist√≥rico do chat: ' + error.message);
        }
      }
    };
    
    loadChatHistory();
  }, [chatSessionId]);

  // Buscar sess√£o existente quando multaId √© definido
  useEffect(() => {
    const loadExistingSession = async () => {
      if (multaId && !chatSessionId) {
        try {
          console.log('üîç === BUSCANDO SESS√ÉO EXISTENTE ===');
          console.log('üÜî Multa ID:', multaId);
          
          // Buscar sess√µes da empresa (usando placeholder por enquanto)
          const sessions = await chatService.getSessionsByCompany('company-id-placeholder', 10);
          console.log('üìã Sess√µes encontradas:', sessions);
          
          // Procurar sess√£o ativa para esta multa
          const existingSession = sessions.find(session => 
            session.multa_id === multaId && session.status === 'active'
          );
          
          if (existingSession) {
            console.log('‚úÖ Sess√£o existente encontrada:', existingSession);
            setChatSessionId(existingSession.id);
            setN8nChatActive(true);
            toast.success('Sess√£o de chat anterior recuperada!');
          } else {
            console.log('‚ÑπÔ∏è Nenhuma sess√£o ativa encontrada para esta multa');
          }
        } catch (error: any) {
          console.error('‚ùå Erro ao buscar sess√£o existente:', error);
          // N√£o mostrar erro para o usu√°rio, apenas log
        }
      }
    };
    
    loadExistingSession();
  }, [multaId, chatSessionId]);

  // Carregar dados do cliente dos par√¢metros de URL
  useEffect(() => {
    console.log('üîç === VERIFICANDO PAR√ÇMETROS DA URL ===');
    console.log('üìã Todos os par√¢metros da URL:', Object.fromEntries(searchParams));
    
    // Novos par√¢metros do CobrancaDetalhes
    const serviceOrderId = searchParams.get('serviceOrderId');
    const clienteId = searchParams.get('clienteId');
    const nome = searchParams.get('nome');
    const cpfCnpj = searchParams.get('cpfCnpj');
    const endereco = searchParams.get('endereco');
    
    // Par√¢metros antigos (para compatibilidade)
    const clientName = searchParams.get('client_name');
    const clientCpf = searchParams.get('client_cpf');
    const clientEndereco = searchParams.get('client_endereco');
    const clientEmail = searchParams.get('client_email');
    const clientTelefone = searchParams.get('client_telefone');
    const paymentId = searchParams.get('payment_id');
    const amountPaid = searchParams.get('amount_paid');
    const multaType = searchParams.get('multa_type');

    console.log('üì• Par√¢metros novos capturados:');
    console.log('  - serviceOrderId:', serviceOrderId);
    console.log('  - clienteId:', clienteId);
    console.log('  - nome:', nome);
    console.log('  - cpfCnpj:', cpfCnpj);
    console.log('  - endereco:', endereco);
    
    console.log('üì• Par√¢metros antigos capturados:');
    console.log('  - clientName:', clientName);
    console.log('  - clientCpf:', clientCpf);
    console.log('  - clientEndereco:', clientEndereco);

    // Priorizar novos par√¢metros, usar antigos como fallback
    const nomeCliente = nome || clientName;
    const cpfCliente = cpfCnpj || clientCpf;
    const enderecoCliente = endereco || clientEndereco;

    console.log('üîÑ Dados finais ap√≥s fallback:');
    console.log('  - nomeCliente:', nomeCliente);
    console.log('  - cpfCliente:', cpfCliente);
    console.log('  - enderecoCliente:', enderecoCliente);

    // Criar dados do cliente mesmo se alguns campos estiverem vazios
    if (nomeCliente || cpfCliente || serviceOrderId) {
      const dadosCliente = {
        nome: nomeCliente || 'Nome n√£o informado',
        cpf_cnpj: cpfCliente || 'CPF/CNPJ n√£o informado',
        endereco: enderecoCliente || 'Endere√ßo n√£o informado',
        email: clientEmail || 'Email n√£o informado',
        telefone: clientTelefone || 'Telefone n√£o informado',
        payment_id: paymentId || serviceOrderId || '',
        amount_paid: amountPaid || '0',
        multa_type: multaType || 'N√£o especificado',
        service_order_id: serviceOrderId || '',
        cliente_id: clienteId || ''
      };
      
      setClienteData(dadosCliente);
      
      console.log('‚úÖ Dados do cliente definidos:', dadosCliente);
      
      toast.success(`Dados do cliente carregados: ${nomeCliente || 'Cliente'}`);
    } else {
      console.log('‚ö†Ô∏è Nenhum dado de cliente encontrado nos par√¢metros');
      toast.info('Nenhum dado de cliente foi enviado. Voc√™ pode prosseguir com o upload do documento.');
    }
  }, [searchParams]);

  const handleFileUpload = async (file: File) => {
    setUploadedFile(file);
    setIsProcessing(true);
    
    try {
      // Verificar se a API do Gemini est√° configurada
      if (!GeminiOcrService.isConfigured()) {
        toast.error('API do Gemini n√£o configurada. Verifique a vari√°vel VITE_GEMINI_API_KEY no arquivo .env');
        setIsProcessing(false);
        return;
      }
      
      toast.info('Iniciando extra√ß√£o de dados do documento...');
      
      // Criar inst√¢ncia do servi√ßo Gemini OCR
      const geminiService = new GeminiOcrService();
      
      // Processar documento com Gemini OCR
      const dadosExtraidos = await geminiService.extrairDadosAutoInfracao(file);
      
      console.log('‚úÖ Dados extra√≠dos do documento:', dadosExtraidos);
      
      // Mapear dados do DocumentoProcessado para MultaData
      const multaDataMapeada: MultaData = {
        // Dados b√°sicos
        numero: dadosExtraidos.numeroAuto || '',
        infracao: dadosExtraidos.descricaoInfracao || '',
        codigoInfracao: dadosExtraidos.codigoInfracao || '',
        local: dadosExtraidos.localInfracao || '',
        data: dadosExtraidos.dataInfracao || '',
        valor: dadosExtraidos.valorMulta ? `R$ ${dadosExtraidos.valorMulta.toFixed(2).replace('.', ',')}` : '',
        veiculo: dadosExtraidos.placaVeiculo || '',
        condutor: dadosExtraidos.condutor || '',
        orgaoAutuador: dadosExtraidos.orgaoAutuador || '',
        pontos: '', // Campo n√£o dispon√≠vel no DocumentoProcessado
        observacoes: dadosExtraidos.observacoes || '',
        
        // Dados do equipamento
        numeroEquipamento: dadosExtraidos.numeroEquipamento || '',
        tipoEquipamento: dadosExtraidos.tipoEquipamento || '',
        localizacaoEquipamento: dadosExtraidos.localInfracao || '', // Usar localInfracao como localiza√ß√£o do equipamento
        velocidadePermitida: '', // Campo n√£o dispon√≠vel diretamente
        velocidadeAferida: '', // Campo n√£o dispon√≠vel diretamente
        
        // Dados do propriet√°rio
        nomeProprietario: dadosExtraidos.nomeProprietario || '',
        cpfCnpjProprietario: dadosExtraidos.cpfCnpjProprietario || '',
        enderecoProprietario: '', // Campo n√£o dispon√≠vel diretamente
        
        // Observa√ß√µes detalhadas
        observacoesGerais: dadosExtraidos.observacoesCompletas || dadosExtraidos.observacoes || '',
        observacoesCondutor: '', // Campo n√£o dispon√≠vel diretamente
        observacoesVeiculo: dadosExtraidos.caracteristicasVeiculo || '',
        mensagemSenatran: dadosExtraidos.mensagemSenatran || '',
        
        // Registro fotogr√°fico
        transcricaoRegistroFotografico: dadosExtraidos.descricaoFoto || '',
        motivoNaoAbordagem: dadosExtraidos.motivoNaoAbordagem || '',
        
        // Dados do equipamento e notifica√ß√£o
        dadosEquipamento: dadosExtraidos.dadosEquipamento || '',
        notificacaoAutuacao: dadosExtraidos.protocoloNotificacao || dadosExtraidos.codigoAcesso || ''
      };
      
      setMultaData(multaDataMapeada);
      setCurrentStep('extraction');
      
      // Salvar dados extra√≠dos automaticamente no banco de dados
      console.log('üíæ === SALVANDO DADOS NO BANCO ===');
      const multaSalva = await handleSaveMultaAutomatically(multaDataMapeada);
      
      if (multaSalva) {
        console.log('‚úÖ Multa salva com UUID:', multaSalva.id);
        setMultaId(multaSalva.id);
        
        // Atualizar service_orders com multa_id se temos serviceOrderId
        if (clienteData?.service_order_id) {
          await updateServiceOrderWithMultaId(clienteData.service_order_id, multaSalva.id);
        }
        
        // Bloquear o processo ap√≥s salvamento bem-sucedido
        setIsProcessLocked(true);
        
        // Salvar processo no localStorage como backup
        const newProcessId = `processo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        setProcessId(newProcessId);
        
        localStorage.setItem('recurso_process', JSON.stringify({
          id: newProcessId,
          multaData: multaDataMapeada,
          multaId: multaSalva.id,
          clienteData,
          timestamp: new Date().toISOString(),
          locked: true
        }));
        
        toast.success(`Dados extra√≠dos e salvos com sucesso! Multa ID: ${multaSalva.id}`);
        
        // üöÄ INICIAR CHAT N8N AUTOMATICAMENTE AP√ìS SALVAMENTO
        console.log('üöÄ === INICIANDO CHAT N8N AUTOMATICAMENTE ===');
        try {
          // Mensagem inicial fixa
          const mensagemInicial = "Analise o auto de infra√ß√£o e verifique inconsist√™ncias conforme regras do MBFT e a justificativa minha justificativa para anular a autua√ß√£o.";
          
          console.log('üí¨ Iniciando chat n8n com mensagem:', mensagemInicial);
          await startN8nChat(mensagemInicial);
          
          console.log('‚úÖ Chat n8n iniciado automaticamente com sucesso!');
          toast.success('ü§ñ Chat com IA iniciado automaticamente!');
        } catch (chatError: any) {
          console.error('‚ùå Erro ao iniciar chat n8n automaticamente:', chatError);
          toast.error(`Erro ao iniciar chat: ${chatError.message}`);
        }
      } else {
        console.warn('‚ö†Ô∏è Falha ao salvar multa no banco, continuando sem salvar');
        toast.warning('Dados extra√≠dos com sucesso, mas n√£o foi poss√≠vel salvar no banco.');
      }
      
    } catch (error: any) {
      console.error('‚ùå Erro na extra√ß√£o OCR:', error);
      
      let errorMessage = 'Erro ao processar documento. ';
      
      if (error.message?.includes('sobrecarregado')) {
        errorMessage += 'Servi√ßo temporariamente indispon√≠vel. Tente novamente em alguns minutos.';
      } else if (error.message?.includes('n√£o cont√©m os dados esperados')) {
        errorMessage += 'Documento pode estar ileg√≠vel ou n√£o ser um auto de infra√ß√£o v√°lido.';
      } else {
        errorMessage += 'Verifique se o arquivo √© um auto de infra√ß√£o v√°lido e tente novamente.';
      }
      
      toast.error(errorMessage);
      
      // Em caso de erro, manter dados vazios
      setMultaData({});
    } finally {
      setIsProcessing(false);
    }
  };

  const handleStartChatClick = async () => {
    console.log('üöÄ === INICIANDO CHATS ===');
    console.log('üìä Estado atual:', {
      currentStep,
      multaDataKeys: Object.keys(multaData),
      isProcessing,
      n8nChatActive,
      multaId: multaId
    });
    
    // Verificar se os dados est√£o dispon√≠veis
    if (Object.keys(multaData).length === 0) {
      console.log('‚ö†Ô∏è Dados da multa n√£o dispon√≠veis');
      toast.error('Dados da multa n√£o dispon√≠veis. Fa√ßa o upload do documento primeiro.');
      return;
    }
    
    // VALIDA√á√ÉO CR√çTICA: Garantir que temos UUID real da multa
    console.log('üîç === VALIDANDO UUID DA MULTA ANTES DO CHAT ===');
    console.log('üÜî multaId atual:', multaId);
    
    let validMultaId = multaId;
    
    // Se n√£o temos multaId, tentar for√ßar salvamento
    if (!validMultaId) {
      console.log('‚ö†Ô∏è multaId n√£o encontrado, for√ßando salvamento da multa...');
      try {
        const multaSalva = await handleSaveMultaAutomatically(multaData);
        if (multaSalva && multaSalva.id) {
          validMultaId = multaSalva.id;
          setMultaId(validMultaId);
          console.log('‚úÖ Multa salva com UUID:', validMultaId);
        }
      } catch (error) {
        console.error('‚ùå Erro ao salvar multa:', error);
      }
    }
    
    // Validar se √© um UUID v√°lido (n√£o tempor√°rio)
    const isValidUUID = validMultaId && 
                       !validMultaId.startsWith('temp_') && 
                       !validMultaId.startsWith('processo_') && 
                       !validMultaId.startsWith('pay_') &&
                       validMultaId.length > 10;
    
    if (!isValidUUID) {
      console.error('‚ùå UUID da multa inv√°lido ou tempor√°rio:', validMultaId);
      toast.error('Erro: N√£o foi poss√≠vel obter o ID v√°lido da multa. Tente fazer upload do documento novamente.');
      return;
    }
    
    console.log('‚úÖ UUID v√°lido confirmado:', validMultaId);
    
    // Mensagem inicial fixa conforme solicitado
    const mensagemInicial = "Analise o auto de infra√ß√£o e verifique inconsist√™ncias conforme regras do MBFT e a justificativa minha justificativa para anular a autua√ß√£o.";
    
    console.log('üí¨ Mensagem inicial:', mensagemInicial);
    
    try {
      // Iniciar ambos os chats simultaneamente
      console.log('üîÑ Iniciando chat n8n...');
      await startN8nChat(mensagemInicial);
      
      console.log('üîÑ Iniciando chat local...');
      startLocalChat();
      
      console.log('‚úÖ Ambos os chats iniciados com sucesso!');
    } catch (error: any) {
      console.error('‚ùå Erro ao iniciar chats:', error);
      toast.error(`Erro ao iniciar chats: ${error.message}`);
    }
  };

  const startN8nChat = async (mensagemInicial: string) => {
    try {
      console.log('üåê Iniciando chat n8n...');
      // N√£o usar setIsProcessing aqui para evitar conflito com extra√ß√£o
      setN8nChatActive(true);
      
      // Usar UUID validado da multa (j√° verificado em handleStartChatClick)
      const multaUUID = multaId;
      
      console.log('üîç === USANDO UUID VALIDADO DA MULTA ===');
      console.log('üÜî UUID da multa (j√° validado):', multaUUID);
      
      // Verifica√ß√£o de seguran√ßa adicional
      if (!multaUUID || multaUUID.startsWith('temp_') || multaUUID.startsWith('pay_')) {
        throw new Error('UUID da multa inv√°lido ou tempor√°rio. N√£o √© poss√≠vel iniciar o chat.');
      }
      
      console.log('‚úÖ UUID final a ser enviado:', multaUUID);
      
      // Preparar dados para o webhook n8n - usar dados do cliente se dispon√≠vel
      const webhookData = {
        nome_requerente: clienteData?.nome || multaData.nomeProprietario || '',
        cpf_cnpj: clienteData?.cpf_cnpj || multaData.cpfCnpjProprietario || '',
        endereco_requerente: clienteData?.endereco || multaData.enderecoProprietario || '',
        placa_veiculo: multaData.veiculo || '',
        renavam_veiculo: '', // Campo n√£o dispon√≠vel nos dados extra√≠dos
        numero_auto: multaData.numero || '',
        data_hora_infracao: multaData.data || '',
        local_infracao: multaData.local || '',
        codigo_infracao: multaData.codigoInfracao || '',
        orgao_autuador: multaData.orgaoAutuador || '',
        idmultabancodedados: multaUUID, // UUID real da multa salva no banco
        mensagem_usuario: mensagemInicial
      };
      
      console.log('üì§ === ENVIANDO DADOS PARA WEBHOOK N8N ===');
      console.log('üÜî UUID da multa enviado:', multaUUID);
      console.log('üìã Dados completos do webhook:', webhookData);
      console.log('üîç Verifica√ß√£o final idmultabancodedados:', webhookData.idmultabancodedados);
      
      // Enviar dados para o webhook n8n
      const response = await fetch('https://webhookn8n.synsoft.com.br/webhook/853f7024-bfd2-4c18-96d2-b98b697c87c4', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(webhookData)
      });
      
      if (!response.ok) {
        throw new Error(`Erro no webhook: ${response.status} - ${response.statusText}`);
      }
      
      const webhookResponse = await response.json();
      console.log('‚úÖ === RESPOSTA DO WEBHOOK N8N (INICIAL) ===');
      console.log('üìã Resposta completa:', webhookResponse);
      console.log('üîç Tipo da resposta:', typeof webhookResponse);
      console.log('üìä √â array?', Array.isArray(webhookResponse));
      
      // Verificar se √© apenas confirma√ß√£o de in√≠cio do workflow
      let responseContent = '';
      const isWorkflowStartMessage = webhookResponse?.message === 'Workflow was started';
      
      if (isWorkflowStartMessage) {
        console.log('‚è≥ === WORKFLOW INICIADO - AGUARDANDO RESPOSTA ===');
        responseContent = `üîÑ Workflow iniciado com sucesso! Aguardando processamento da IA...\n\nDados enviados:\n‚Ä¢ Auto de Infra√ß√£o: ${multaData.numero}\n‚Ä¢ C√≥digo: ${multaData.codigoInfracao}\n‚Ä¢ Local: ${multaData.local}\n\nO sistema est√° analisando sua solicita√ß√£o. A resposta aparecer√° em breve.`;
        
        // Implementar verifica√ß√£o peri√≥dica para aguardar resposta real
         // Como o n8n est√° configurado de forma ass√≠ncrona, vamos usar uma abordagem diferente
         let pollAttempts = 0;
         const maxPollAttempts = 8;
         const pollInterval = setInterval(async () => {
           pollAttempts++;
           console.log(`üîÑ Verifica√ß√£o ${pollAttempts}/${maxPollAttempts} - Aguardando resposta do n8n...`);
           
           try {
             // Tentar uma abordagem diferente: usar um par√¢metro de status
             const statusResponse = await fetch('https://webhookn8n.synsoft.com.br/webhook/853f7024-bfd2-4c18-96d2-b98b697c87c4', {
               method: 'POST',
               headers: {
                 'Content-Type': 'application/json',
               },
               body: JSON.stringify({
                 ...webhookData,
                 action: 'get_status',
                 session_id: chatSessionId || processId,
                 check_attempt: pollAttempts
               })
             });
             
             if (statusResponse.ok) {
               const statusResult = await statusResponse.json();
               console.log(`üìã Resposta da verifica√ß√£o ${pollAttempts}:`, statusResult);
               
               // Verificar se recebemos uma resposta real
               const hasRealResponse = statusResult && 
                                     statusResult.message !== 'Workflow was started' &&
                                     (Array.isArray(statusResult) || statusResult.response);
               
               if (hasRealResponse) {
                 console.log('‚úÖ Resposta real recebida!');
                 clearInterval(pollInterval);
                 
                 // Processar e atualizar a resposta
                 let realContent = '';
                 if (Array.isArray(statusResult)) {
                   realContent = statusResult[0]?.response || statusResult[0]?.message || JSON.stringify(statusResult[0]);
                 } else {
                   realContent = statusResult.response || statusResult.message || JSON.stringify(statusResult);
                 }
                 
                 // Atualizar a mensagem no chat
                 setN8nChatMessages(prev => {
                   const updated = [...prev];
                   if (updated.length > 1) {
                     updated[1] = {
                       ...updated[1],
                       content: realContent,
                       timestamp: new Date()
                     };
                   }
                   return updated;
                 });
                 
                 // Salvar no banco se temos sess√£o
                 if (chatSessionId) {
                   try {
                     await chatService.addMessage({
                       chatSessionId: chatSessionId,
                       messageType: 'assistant',
                       content: realContent,
                       metadata: { 
                         source: 'n8n_delayed_response',
                         attempt: pollAttempts,
                         timestamp: new Date().toISOString()
                       }
                     });
                     
                     // Detectar recurso se presente
                     if (multaId) {
                       try {
                         const recursoDetectado = await detectarESalvarRecurso(realContent, chatSessionId, multaId);
                         if (recursoDetectado) {
                           toast.success('üéØ Resposta da IA recebida e recurso detectado!');
                         } else {
                           toast.success('‚úÖ Resposta da IA recebida!');
                         }
                       } catch (recursoError: any) {
                         console.error('‚ùå Erro ao detectar recurso:', recursoError);
                         toast.success('‚úÖ Resposta da IA recebida!');
                       }
                     } else {
                       toast.success('‚úÖ Resposta da IA recebida!');
                     }
                   } catch (saveError: any) {
                     console.warn('‚ö†Ô∏è Erro ao salvar resposta:', saveError);
                     toast.success('‚úÖ Resposta da IA recebida!');
                   }
                 }
                 
                 return;
               }
             }
           } catch (pollError: any) {
             console.warn(`‚ö†Ô∏è Erro na verifica√ß√£o ${pollAttempts}:`, pollError.message);
           }
           
           // Se atingiu o m√°ximo de tentativas, parar
           if (pollAttempts >= maxPollAttempts) {
             console.log('‚è∞ Tempo limite atingido para resposta do n8n');
             clearInterval(pollInterval);
             
             // Atualizar mensagem para indicar que est√° processando em background
             setN8nChatMessages(prev => {
               const updated = [...prev];
               if (updated.length > 1) {
                 updated[1] = {
                   ...updated[1],
                   content: `üîÑ Sua solicita√ß√£o est√° sendo processada pelo sistema de IA.\n\nDados enviados:\n‚Ä¢ Auto de Infra√ß√£o: ${multaData.numero}\n‚Ä¢ C√≥digo: ${multaData.codigoInfracao}\n‚Ä¢ Local: ${multaData.local}\n\n‚è∞ O processamento pode levar alguns minutos. A resposta aparecer√° automaticamente quando estiver pronta.\n\nüí° Voc√™ pode continuar enviando mensagens ou aguardar a resposta.`,
                   timestamp: new Date()
                 };
               }
               return updated;
             });
             
             toast.info('‚è∞ O sistema est√° processando sua solicita√ß√£o. A resposta pode demorar alguns minutos.');
           }
         }, 5000); // Verificar a cada 5 segundos
        
      } else if (Array.isArray(webhookResponse) && webhookResponse.length > 0) {
        // Se for array, pegar o primeiro item e extrair a resposta
        const firstItem = webhookResponse[0];
        responseContent = firstItem.response || firstItem.message || JSON.stringify(firstItem);
        console.log('üìã Processando array - primeiro item:', firstItem);
        console.log('üí¨ Conte√∫do extra√≠do do array:', responseContent);
      } else if (webhookResponse && typeof webhookResponse === 'object' && !isWorkflowStartMessage) {
        // Se for objeto direto (mas n√£o a mensagem de in√≠cio)
        responseContent = webhookResponse.response || webhookResponse.message || JSON.stringify(webhookResponse);
        console.log('üí¨ Conte√∫do extra√≠do do objeto:', responseContent);
      } else {
        // Fallback
        responseContent = `Recebi sua solicita√ß√£o para an√°lise do auto de infra√ß√£o n¬∫ ${multaData.numero}. Vou analisar as inconsist√™ncias conforme as regras do MBFT.`;
        console.log('‚ö†Ô∏è Usando conte√∫do fallback');
      }
      
      // Adicionar mensagem inicial ao chat n8n
      const initialUserMessage = {
        id: 'n8n_1',
        type: 'user' as const,
        content: mensagemInicial,
        timestamp: new Date()
      };
      
      const initialAiMessage = {
        id: 'n8n_2',
        type: 'ai' as const,
        content: responseContent,
        timestamp: new Date()
      };
      
      setN8nChatMessages([initialUserMessage, initialAiMessage]);
      
      // Salvar sess√£o de chat no banco de dados
       const sessionId = `chat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
       
       try {
         // Primeiro salvar a multa se ainda n√£o foi salva
         let currentMultaId = multaId;
         if (!currentMultaId && Object.keys(multaData).length > 0) {
           const multaSalva = await handleSaveMulta();
           currentMultaId = multaSalva?.id || null;
           setMultaId(currentMultaId);
         }
         
         // Criar sess√£o de chat
         const chatSession = await chatService.createSession({
           sessionId,
           webhookUrl: 'https://webhookn8n.synsoft.com.br/webhook/853f7024-bfd2-4c18-96d2-b98b697c87c4',
           webhookPayload: webhookData,
           multaId: currentMultaId,
           companyId: 'company-id-placeholder', // TODO: Obter do contexto de autentica√ß√£o
           userId: 'user-id-placeholder' // TODO: Obter do contexto de autentica√ß√£o
         });
         
         setChatSessionId(chatSession.id);
         console.log('‚úÖ Sess√£o de chat criada:', chatSession);
         
         // Salvar mensagens iniciais no banco de dados
         try {
           await chatService.addMessage({
             chatSessionId: chatSession.id,
             messageType: 'user',
             content: mensagemInicial,
             metadata: { source: 'n8n_initial' }
           });
           
           await chatService.addMessage({
              chatSessionId: chatSession.id,
              messageType: 'assistant',
              content: responseContent,
              metadata: { 
                source: 'n8n_webhook',
                webhookResponse: webhookResponse,
                responseContent: responseContent,
                timestamp: new Date().toISOString()
              }
            });
           
           console.log('‚úÖ === MENSAGENS INICIAIS SALVAS NO BANCO ===');
           console.log('üÜî Session ID:', chatSession.id);
           console.log('üí¨ Mensagem do usu√°rio salva:', mensagemInicial);
           console.log('ü§ñ Resposta da IA salva:', responseContent);
           console.log('üìã Resposta original do webhook:', webhookResponse);
           
           // Detectar e salvar recurso se presente na resposta inicial
           if (currentMultaId) {
             console.log('üîç === INICIANDO DETEC√á√ÉO DE RECURSO (INICIAL) ===');
             console.log('üìã Dados para detec√ß√£o:', {
               responseLength: responseContent.length,
               chatSessionId: chatSession.id,
               multaId: currentMultaId,
               hasMultaData: Object.keys(multaData).length > 0
             });
             
             try {
               const recursoDetectado = await detectarESalvarRecurso(responseContent, chatSession.id, currentMultaId);
               if (recursoDetectado) {
                 console.log('‚úÖ Recurso detectado e salvo na resposta inicial:', recursoDetectado.id);
               } else {
                 console.log('‚ÑπÔ∏è Nenhum recurso detectado na resposta inicial');
               }
             } catch (recursoError: any) {
               console.error('‚ùå Erro ao detectar/salvar recurso inicial:', recursoError);
               toast.warning('Erro ao processar recurso da resposta inicial');
             }
           }
         } catch (messageError: any) {
           console.warn('‚ö†Ô∏è Erro ao salvar mensagens iniciais:', messageError);
         }
         
       } catch (sessionError: any) {
         console.warn('‚ö†Ô∏è Erro ao salvar sess√£o de chat:', sessionError);
         // Continuar mesmo se n√£o conseguir salvar a sess√£o
       }
      
      toast.success('Chat n8n iniciado com sucesso! Dados enviados para o sistema de IA.');
      
    } catch (error: any) {
      console.error('‚ùå Erro ao iniciar chat n8n:', error);
      toast.error(`Erro ao conectar com o sistema n8n: ${error.message}`);
      setN8nChatActive(false); // Resetar estado em caso de erro
    }
  };
  


  const sendN8nMessage = async (message: string) => {
    if (!message.trim() || isN8nLoading) return;
    
    try {
      setIsN8nLoading(true);
      
      // Adicionar mensagem do usu√°rio ao chat
      const userMessage: ChatMessage = {
        id: `n8n_user_${Date.now()}`,
        type: 'user',
        content: message,
        timestamp: new Date()
      };
      
      setN8nChatMessages(prev => [...prev, userMessage]);
      setN8nInputValue('');
      
      // Usar UUID validado da multa (deve estar dispon√≠vel ap√≥s inicializa√ß√£o do chat)
      const multaUUID = multaId;
      
      console.log('üîç === USANDO UUID VALIDADO DA MULTA (MENSAGEM) ===');
      console.log('üÜî UUID da multa:', multaUUID);
      
      // Verifica√ß√£o de seguran√ßa: n√£o permitir IDs inv√°lidos
      if (!multaUUID || multaUUID.startsWith('temp_') || multaUUID.startsWith('pay_')) {
        console.error('‚ùå UUID da multa inv√°lido para envio de mensagem:', multaUUID);
        throw new Error('UUID da multa inv√°lido. Reinicie o chat.');
      }
      
      console.log('‚úÖ UUID final a ser enviado:', multaUUID);
      
      // Preparar dados para o webhook n8n
      const webhookData = {
        nome_requerente: clienteData?.nome || multaData.condutor || multaData.nomeProprietario || '',
        cpf_cnpj: clienteData?.cpf_cnpj || multaData.cpfCnpjProprietario || '',
        endereco_requerente: clienteData?.endereco || multaData.enderecoProprietario || '',
        placa_veiculo: multaData.veiculo || '',
        renavam_veiculo: '',
        numero_auto: multaData.numero || '',
        data_hora_infracao: multaData.data || '',
        local_infracao: multaData.local || '',
        codigo_infracao: multaData.codigoInfracao || '',
        orgao_autuador: multaData.orgaoAutuador || '',
        idmultabancodedados: multaUUID, // UUID correto da multa
        mensagem_usuario: message,
        session_id: chatSessionId || processId
      };
      
      console.log('üì§ === ENVIANDO MENSAGEM PARA WEBHOOK N8N ===');
      console.log('üí¨ Mensagem do usu√°rio:', message);
      console.log('üÜî UUID da multa enviado:', multaUUID);
      console.log('üìã Dados completos do webhook:', webhookData);
      console.log('üîç Verifica√ß√£o final idmultabancodedados:', webhookData.idmultabancodedados);
      
      // Enviar mensagem para o webhook n8n
      const response = await fetch('https://webhookn8n.synsoft.com.br/webhook/853f7024-bfd2-4c18-96d2-b98b697c87c4', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(webhookData)
      });
      
      if (!response.ok) {
        throw new Error(`Erro no webhook: ${response.status} - ${response.statusText}`);
      }
      
      const webhookResponse = await response.json();
      console.log('‚úÖ === RESPOSTA DO WEBHOOK N8N (MENSAGEM) ===');
      console.log('üìã Resposta completa:', webhookResponse);
      console.log('üîç Tipo da resposta:', typeof webhookResponse);
      console.log('üìä √â array?', Array.isArray(webhookResponse));
      
      // Verificar se √© apenas confirma√ß√£o de in√≠cio do workflow
      const isWorkflowStartMessage = webhookResponse?.message === 'Workflow was started';
      
      if (isWorkflowStartMessage) {
        console.log('‚è≥ === WORKFLOW INICIADO PARA MENSAGEM - AGUARDANDO RESPOSTA ===');
        
        // Adicionar mensagem tempor√°ria indicando processamento
        const processingMessage: ChatMessage = {
          id: `n8n_processing_${Date.now()}`,
          type: 'ai',
          content: 'üîÑ Processando sua mensagem... Aguarde a resposta da IA.',
          timestamp: new Date()
        };
        
        setN8nChatMessages(prev => [...prev, processingMessage]);
        
        // Implementar verifica√ß√£o peri√≥dica para mensagens subsequentes
         let messagePollAttempts = 0;
         const maxMessagePollAttempts = 6;
         const messagePollInterval = setInterval(async () => {
           messagePollAttempts++;
           console.log(`üîÑ Verifica√ß√£o de mensagem ${messagePollAttempts}/${maxMessagePollAttempts}...`);
           
           try {
             const messageStatusResponse = await fetch('https://webhookn8n.synsoft.com.br/webhook/853f7024-bfd2-4c18-96d2-b98b697c87c4', {
               method: 'POST',
               headers: {
                 'Content-Type': 'application/json',
               },
               body: JSON.stringify({
                 ...webhookData,
                 action: 'get_message_status',
                 session_id: chatSessionId || processId,
                 message_check_attempt: messagePollAttempts,
                 original_message: message
               })
             });
             
             if (messageStatusResponse.ok) {
               const messageStatusResult = await messageStatusResponse.json();
               console.log(`üìã Resposta da verifica√ß√£o de mensagem ${messagePollAttempts}:`, messageStatusResult);
               
               const hasMessageResponse = messageStatusResult && 
                                        messageStatusResult.message !== 'Workflow was started' &&
                                        (Array.isArray(messageStatusResult) || messageStatusResult.response);
               
               if (hasMessageResponse) {
                 console.log('‚úÖ Resposta da mensagem recebida!');
                 clearInterval(messagePollInterval);
                 
                 // Processar resposta da mensagem
                 let messageContent = '';
                 if (Array.isArray(messageStatusResult)) {
                   messageContent = messageStatusResult[0]?.response || messageStatusResult[0]?.message || JSON.stringify(messageStatusResult[0]);
                 } else {
                   messageContent = messageStatusResult.response || messageStatusResult.message || JSON.stringify(messageStatusResult);
                 }
                 
                 // Remover mensagem de processamento e adicionar resposta real
                 setN8nChatMessages(prev => {
                   const filtered = prev.filter(msg => !msg.id.startsWith('n8n_processing_'));
                   return [...filtered, {
                     id: `n8n_ai_${Date.now()}`,
                     type: 'ai',
                     content: messageContent,
                     timestamp: new Date()
                   }];
                 });
                 
                 // Salvar no banco se temos sess√£o
                 if (chatSessionId) {
                   try {
                     // Salvar mensagem do usu√°rio
                     await chatService.addMessage({
                       chatSessionId: chatSessionId,
                       messageType: 'user',
                       content: message,
                       metadata: { source: 'n8n_user_input' }
                     });
                     
                     // Salvar resposta da IA
                     await chatService.addMessage({
                       chatSessionId: chatSessionId,
                       messageType: 'assistant',
                       content: messageContent,
                       metadata: { 
                         source: 'n8n_delayed_message_response',
                         attempt: messagePollAttempts,
                         timestamp: new Date().toISOString()
                       }
                     });
                     
                     // Detectar recurso se presente
                     if (multaUUID) {
                       try {
                         const recursoDetectado = await detectarESalvarRecurso(messageContent, chatSessionId, multaUUID);
                         if (recursoDetectado) {
                           toast.success('üéØ Resposta recebida e recurso detectado!');
                         } else {
                           toast.success('‚úÖ Resposta da IA recebida!');
                         }
                       } catch (recursoError: any) {
                         console.error('‚ùå Erro ao detectar recurso:', recursoError);
                         toast.success('‚úÖ Resposta da IA recebida!');
                       }
                     } else {
                       toast.success('‚úÖ Resposta da IA recebida!');
                     }
                   } catch (saveError: any) {
                     console.warn('‚ö†Ô∏è Erro ao salvar resposta da mensagem:', saveError);
                     toast.success('‚úÖ Resposta da IA recebida!');
                   }
                 }
                 
                 return;
               }
             }
           } catch (pollError: any) {
             console.warn(`‚ö†Ô∏è Erro na verifica√ß√£o de mensagem ${messagePollAttempts}:`, pollError.message);
           }
           
           // Se atingiu o m√°ximo de tentativas, parar e mostrar timeout
           if (messagePollAttempts >= maxMessagePollAttempts) {
             console.log('‚è∞ Tempo limite atingido para resposta da mensagem');
             clearInterval(messagePollInterval);
             
             // Remover mensagem de processamento e adicionar timeout
             setN8nChatMessages(prev => {
               const filtered = prev.filter(msg => !msg.id.startsWith('n8n_processing_'));
               return [...filtered, {
                 id: `n8n_timeout_${Date.now()}`,
                 type: 'ai',
                 content: '‚è∞ O sistema est√° processando sua mensagem em background. A resposta pode demorar alguns minutos. Voc√™ pode continuar enviando mensagens.',
                 timestamp: new Date()
               }];
             });
             
             toast.info('‚è∞ Sua mensagem est√° sendo processada. A resposta pode demorar alguns minutos.');
           }
         }, 4000); // Verificar a cada 4 segundos para mensagens
        
      } else {
        // Processar resposta imediata (caso o n8n retorne resposta direta)
        let responseContent = '';
        if (Array.isArray(webhookResponse) && webhookResponse.length > 0) {
          // Se for array, pegar o primeiro item e extrair a resposta
          const firstItem = webhookResponse[0];
          responseContent = firstItem.response || firstItem.message || JSON.stringify(firstItem);
          console.log('üìã Processando array - primeiro item:', firstItem);
          console.log('üí¨ Conte√∫do extra√≠do do array:', responseContent);
        } else if (webhookResponse && typeof webhookResponse === 'object') {
          // Se for objeto direto
          responseContent = webhookResponse.response || webhookResponse.message || JSON.stringify(webhookResponse);
          console.log('üí¨ Conte√∫do extra√≠do do objeto:', responseContent);
        } else {
          // Fallback
          responseContent = 'Mensagem recebida e processada pelo sistema n8n.';
          console.log('‚ö†Ô∏è Usando conte√∫do fallback para mensagem');
        }
        
        // Adicionar resposta da IA ao chat
        const aiMessage: ChatMessage = {
          id: `n8n_ai_${Date.now()}`,
          type: 'ai',
          content: responseContent,
          timestamp: new Date()
        };
        
        setN8nChatMessages(prev => [...prev, aiMessage]);
        
        // Salvar mensagens no banco de dados se temos uma sess√£o ativa
        if (chatSessionId) {
          try {
            // Salvar mensagem do usu√°rio
            await chatService.addMessage({
              chatSessionId: chatSessionId,
              messageType: 'user',
              content: message,
              metadata: { source: 'n8n_user_input' }
            });
            
            // Salvar resposta da IA
             await chatService.addMessage({
               chatSessionId: chatSessionId,
               messageType: 'assistant',
               content: responseContent,
               metadata: { 
                 source: 'n8n_webhook_response',
                 webhookResponse: webhookResponse,
                 responseContent: responseContent,
                 timestamp: new Date().toISOString()
               }
             });
            
            console.log('‚úÖ === MENSAGENS DO CHAT SALVAS NO BANCO ===');
             console.log('üÜî Session ID:', chatSessionId);
             console.log('üí¨ Mensagem do usu√°rio salva:', message);
             console.log('ü§ñ Resposta da IA salva:', responseContent);
             console.log('üìã Resposta original do webhook:', webhookResponse);
             console.log('üìä Metadata da resposta:', { source: 'n8n_webhook_response', timestamp: new Date().toISOString() });
             
             // Detectar e salvar recurso se presente na resposta
             if (multaUUID) {
               console.log('üîç === INICIANDO DETEC√á√ÉO DE RECURSO (MENSAGEM) ===');
               console.log('üìã Dados para detec√ß√£o:', {
                 responseLength: responseContent.length,
                 chatSessionId: chatSessionId,
                 multaId: multaUUID,
                 userMessage: message.substring(0, 50) + '...'
               });
               
               try {
                 const recursoDetectado = await detectarESalvarRecurso(responseContent, chatSessionId, multaUUID);
                 if (recursoDetectado) {
                   console.log('‚úÖ Recurso detectado e salvo na mensagem:', recursoDetectado.id);
                   toast.success('üéØ Novo recurso detectado e salvo!');
                 } else {
                   console.log('‚ÑπÔ∏è Nenhum recurso detectado na mensagem');
                 }
               } catch (recursoError: any) {
                 console.error('‚ùå Erro ao detectar/salvar recurso da mensagem:', recursoError);
                 toast.warning('Erro ao processar recurso da resposta');
               }
             }
          } catch (messageError: any) {
            console.warn('‚ö†Ô∏è Erro ao salvar mensagens no banco:', messageError);
          }
        }
      }
      
    } catch (error: any) {
      console.error('‚ùå Erro ao enviar mensagem n8n:', error);
      toast.error(`Erro ao enviar mensagem: ${error.message}`);
      
      // Adicionar mensagem de erro ao chat
      const errorMessage: ChatMessage = {
        id: `n8n_error_${Date.now()}`,
        type: 'ai',
        content: `Desculpe, ocorreu um erro ao processar sua mensagem: ${error.message}`,
        timestamp: new Date()
      };
      
      setN8nChatMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsN8nLoading(false);
    }
  };

  const handleN8nKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendN8nMessage(n8nInputValue);
    }
  };

  const handleNewProcess = () => {
    // Limpar todos os dados e reiniciar o processo
    setIsProcessLocked(false);
    setProcessId(null);
    setUploadedFile(null);
    setMultaData({});
    setN8nChatMessages([]);
    setN8nChatActive(false);
    setRecursoText('');
    setCurrentStep('upload');
    
    // Limpar localStorage
    localStorage.removeItem('recurso_process');
    
    toast.success('Novo processo iniciado! Voc√™ pode fazer upload de um novo documento.');
  };


  
  const handleRecursoChange = (newText: string) => {
    setRecursoText(newText);
  };
  
  // Fun√ß√£o para converter data do formato brasileiro (DD/MM/YYYY) para ISO (YYYY-MM-DD)
  const convertBrazilianDateToISO = (dateString: string): string => {
    if (!dateString) {
      console.log('‚ö†Ô∏è Data vazia, usando data atual como fallback');
      return new Date().toISOString().split('T')[0];
    }
    
    console.log('üîÑ Convertendo data:', dateString);
    
    // Verificar se j√° est√° no formato ISO (YYYY-MM-DD)
    if (/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
      console.log('‚úÖ Data j√° est√° no formato ISO:', dateString);
      return dateString;
    }
    
    // Verificar formato brasileiro (DD/MM/YYYY)
    const brazilianDateMatch = dateString.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (brazilianDateMatch) {
      const [, day, month, year] = brazilianDateMatch;
      const isoDate = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
      console.log('‚úÖ Data convertida de', dateString, 'para', isoDate);
      return isoDate;
    }
    
    // Tentar outros formatos comuns
    const otherFormats = [
      /^(\d{1,2})-(\d{1,2})-(\d{4})$/, // DD-MM-YYYY
      /^(\d{4})\/(\d{1,2})\/(\d{1,2})$/, // YYYY/MM/DD
    ];
    
    for (const format of otherFormats) {
      const match = dateString.match(format);
      if (match) {
        const [, part1, part2, part3] = match;
        // Assumir que se o primeiro n√∫mero tem 4 d√≠gitos, √© ano
        if (part1.length === 4) {
          const isoDate = `${part1}-${part2.padStart(2, '0')}-${part3.padStart(2, '0')}`;
          console.log('‚úÖ Data convertida de', dateString, 'para', isoDate);
          return isoDate;
        } else {
          const isoDate = `${part3}-${part2.padStart(2, '0')}-${part1.padStart(2, '0')}`;
          console.log('‚úÖ Data convertida de', dateString, 'para', isoDate);
          return isoDate;
        }
      }
    }
    
    console.warn('‚ö†Ô∏è Formato de data n√£o reconhecido:', dateString, '- usando data atual como fallback');
     return new Date().toISOString().split('T')[0];
   };
   
   // Fun√ß√£o para validar se uma data ISO √© v√°lida
   const validateISODate = (isoDateString: string): boolean => {
     if (!isoDateString || !/^\d{4}-\d{2}-\d{2}$/.test(isoDateString)) {
       console.log('‚ùå Formato de data inv√°lido:', isoDateString);
       return false;
     }
     
     const date = new Date(isoDateString + 'T00:00:00.000Z');
     
     // Verificar se a data √© v√°lida (n√£o √© NaN)
     if (isNaN(date.getTime())) {
       console.log('‚ùå Data inv√°lida (NaN):', isoDateString);
       return false;
     }
     
     // Verificar se os componentes da data s√£o v√°lidos
     const [year, month, day] = isoDateString.split('-').map(Number);
     
     if (year < 1900 || year > 2100) {
       console.log('‚ùå Ano fora do intervalo v√°lido:', year);
       return false;
     }
     
     if (month < 1 || month > 12) {
       console.log('‚ùå M√™s inv√°lido:', month);
       return false;
     }
     
     if (day < 1 || day > 31) {
       console.log('‚ùå Dia inv√°lido:', day);
       return false;
     }
     
     console.log('‚úÖ Data v√°lida:', isoDateString);
     return true;
   };
  
  const handleSaveMultaAutomatically = async (multaDataMapeada: MultaData) => {
    try {
      console.log('üíæ Salvando dados da multa automaticamente...');
      console.log('üìã Dados a serem salvos:', multaDataMapeada);
      console.log('üë§ Dados do cliente:', clienteData);
      
      // Buscar company_id existente no banco
      let companyId = await getExistingCompanyId();
      
      // Se n√£o encontrou company existente, usar dados do cliente ou gerar UUID
      if (!companyId) {
        console.log('‚ö†Ô∏è Nenhuma company encontrada, usando fallback...');
        companyId = getValidUUID(clienteData?.cliente_id, 'Company ID (multa)');
      }
      
      // Buscar client_id existente no banco
      let clientId = await getExistingClientId();
      
      // Se n√£o encontrou client existente, tentar criar um cliente padr√£o
      if (!clientId && companyId) {
        console.log('‚ö†Ô∏è Nenhum client encontrado, tentando criar cliente padr√£o...');
        clientId = await createDefaultClient(companyId, clienteData);
      }
      
      // Se ainda n√£o temos client_id, usar fallback com UUID
      if (!clientId) {
        console.log('‚ö†Ô∏è N√£o foi poss√≠vel criar cliente padr√£o, usando fallback UUID...');
        clientId = getValidUUID(clienteData?.cliente_id, 'Client ID (multa)');
      }
      
      console.log('üè¢ Company ID final a ser usado:', companyId);
      console.log('üë§ Client ID final a ser usado:', clientId);
      
      // Converter data da infra√ß√£o do formato brasileiro para ISO
      let dataInfracaoISO = convertBrazilianDateToISO(multaDataMapeada.data || '');
      
      // Validar se a data convertida √© v√°lida
      if (!validateISODate(dataInfracaoISO)) {
        console.error('‚ùå Data convertida √© inv√°lida:', dataInfracaoISO);
        const fallbackDate = new Date().toISOString().split('T')[0];
        console.log('üîÑ Usando data atual como fallback:', fallbackDate);
        dataInfracaoISO = fallbackDate;
      }
      
      console.log('üìÖ Data da infra√ß√£o processada:', {
        original: multaDataMapeada.data,
        convertida: dataInfracaoISO,
        valida: validateISODate(dataInfracaoISO)
      });
      
      // Preparar dados da multa com todos os campos expandidos
      const multaInsert = {
        company_id: companyId,
        client_id: clientId,
        numero_auto: multaDataMapeada.numero || '',
        placa_veiculo: multaDataMapeada.veiculo || '',
        data_infracao: dataInfracaoISO,
        data_vencimento: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 30 dias
        valor_original: parseFloat(multaDataMapeada.valor?.replace(/[^\d,]/g, '').replace(',', '.') || '0'),
        valor_final: parseFloat(multaDataMapeada.valor?.replace(/[^\d,]/g, '').replace(',', '.') || '0'),
        codigo_infracao: multaDataMapeada.codigoInfracao || '',
        local_infracao: multaDataMapeada.local || '',
        descricao_infracao: multaDataMapeada.infracao || '',
        orgao_autuador: multaDataMapeada.orgaoAutuador || '',
        pontos: parseInt(multaDataMapeada.pontos || '0'),
        observacoes: multaDataMapeada.observacoes || '',
        
        // Campos expandidos - Dados do equipamento
        numero_equipamento: multaDataMapeada.numeroEquipamento || null,
        tipo_equipamento: multaDataMapeada.tipoEquipamento || null,
        localizacao_equipamento: multaDataMapeada.localizacaoEquipamento || null,
        velocidade_permitida: multaDataMapeada.velocidadePermitida || null,
        velocidade_aferida: multaDataMapeada.velocidadeAferida || null,
        
        // Campos expandidos - Dados do propriet√°rio
        nome_proprietario: multaDataMapeada.nomeProprietario || null,
        cpf_cnpj_proprietario: multaDataMapeada.cpfCnpjProprietario || null,
        endereco_proprietario: multaDataMapeada.enderecoProprietario || null,
        
        // Campos expandidos - Observa√ß√µes detalhadas
        observacoes_gerais: multaDataMapeada.observacoesGerais || null,
        observacoes_condutor: multaDataMapeada.observacoesCondutor || null,
        observacoes_veiculo: multaDataMapeada.observacoesVeiculo || null,
        mensagem_senatran: multaDataMapeada.mensagemSenatran || null,
        
        // Campos expandidos - Registro fotogr√°fico
        transcricao_registro_fotografico: multaDataMapeada.transcricaoRegistroFotografico || null,
        motivo_nao_abordagem: multaDataMapeada.motivoNaoAbordagem || null,
        
        // Campos expandidos - Dados do equipamento e notifica√ß√£o
        dados_equipamento: multaDataMapeada.dadosEquipamento || null,
        notificacao_autuacao: multaDataMapeada.notificacaoAutuacao || null
      };
      
      // Validar dados antes do salvamento
      console.log('üîç === VALIDA√á√ÉO COMPLETA DOS DADOS ===');
      console.log('üìä Dados de identifica√ß√£o:');
      console.log('  - Company ID:', companyId, '(tipo:', typeof companyId, ')');
      console.log('  - Client ID:', clientId, '(tipo:', typeof clientId, ')');
      
      // Validar se os IDs s√£o v√°lidos antes de prosseguir
      if (!companyId || !clientId) {
        const errorMsg = `IDs inv√°lidos - Company ID: ${companyId}, Client ID: ${clientId}`;
        console.error('‚ùå ERRO:', errorMsg);
        throw new Error(errorMsg);
      }
      
      console.log('‚úÖ Valida√ß√£o de IDs passou - ambos os IDs s√£o v√°lidos');
      console.log('üìã Dados da multa:');
      console.log('  - N√∫mero da multa:', multaInsert.numero_auto);
      console.log('  - Placa do ve√≠culo:', multaInsert.placa_veiculo);
      console.log('  - C√≥digo da infra√ß√£o:', multaInsert.codigo_infracao);
      console.log('  - Local da infra√ß√£o:', multaInsert.local_infracao);
      console.log('  - Descri√ß√£o da infra√ß√£o:', multaInsert.descricao_infracao);
      console.log('  - √ìrg√£o autuador:', multaInsert.orgao_autuador);
      console.log('  - Pontos:', multaInsert.pontos);
      console.log('üìÖ Dados de data:');
      console.log('  - Data original:', multaDataMapeada.data);
      console.log('  - Data da infra√ß√£o (ISO):', multaInsert.data_infracao);
      console.log('  - Data de vencimento:', multaInsert.data_vencimento);
      console.log('üí∞ Dados financeiros:');
      console.log('  - Valor original string:', multaDataMapeada.valor);
      console.log('  - Valor original processado:', multaInsert.valor_original);
      console.log('  - Valor final:', multaInsert.valor_final);
      console.log('üìù Observa√ß√µes:', multaInsert.observacoes);
      
      console.log('üíæ === INICIANDO SALVAMENTO NO BANCO ===');
      
      // Salvar multa usando o servi√ßo
      const multaSalva = await multasService.createMulta(multaInsert);
      
      console.log('‚úÖ === SALVAMENTO CONCLU√çDO ===');
      
      // === AN√ÅLISE DE MULTA LEVE ===
      if (multaSalva?.id && multaDataMapeada.codigoInfracao) {
        console.log('üîç === INICIANDO AN√ÅLISE DE MULTA LEVE ===');
        
        try {
          // Obter CPF do condutor (priorizar propriet√°rio, depois cliente)
        const cpfCondutor = multaDataMapeada.cpfCnpjProprietario || 
                           clienteData?.cpf_cnpj || 
                           '';
          
          if (cpfCondutor && cpfCondutor !== 'CPF/CNPJ n√£o informado') {
            console.log('üë§ CPF do condutor para an√°lise:', cpfCondutor);
            
            // Realizar an√°lise completa de multa leve
             const resultadoAnalise = await multaLeveService.analisarMultaLeve(
               multaDataMapeada.codigoInfracao,
               cpfCondutor,
               new Date(multaInsert.data_infracao)
             );
             
             // Determinar tipo de gravidade
             const tipoGravidade = multaLeveService.determinarTipoGravidade(
               multaDataMapeada.codigoInfracao
             );
             
             // Atualizar campos no banco de dados
             await multaLeveService.atualizarCamposMultaLeve(
               multaSalva.id,
               resultadoAnalise,
               tipoGravidade
             );
             
             // Armazenar resultado da an√°lise no estado
             setAnaliseMultaLeve(resultadoAnalise);
             
             // Log dos resultados
             console.log('üìä === RESULTADOS DA AN√ÅLISE ===');
             console.log('üè∑Ô∏è Tipo de gravidade:', tipoGravidade);
             console.log('üìã √â multa leve:', resultadoAnalise.isMultaLeve);
             console.log('üìà Tem hist√≥rico 12m:', resultadoAnalise.historicoCondutor.temHistorico);
             console.log('üìù Sugerir advert√™ncia:', resultadoAnalise.advertencia.sugerirAdvertencia);
             console.log('üí¨ Motivo:', resultadoAnalise.advertencia.motivo);
             
             // Mostrar toast informativo e exibir advert√™ncia se aplic√°vel
             if (resultadoAnalise.isMultaLeve) {
               if (resultadoAnalise.advertencia.sugerirAdvertencia) {
                 toast.success('‚úÖ Multa leve identificada! Advert√™ncia por escrito sugerida.');
                 // Exibir componente de advert√™ncia automaticamente
                 setShowAdvertencia(true);
               } else {
                 toast.info(`‚ÑπÔ∏è Multa leve identificada. ${resultadoAnalise.advertencia.motivo}`);
               }
             } else {
               toast.info(`‚ÑπÔ∏è Multa classificada como: ${tipoGravidade}`);
             }
            
          } else {
            console.log('‚ö†Ô∏è CPF do propriet√°rio/cliente n√£o dispon√≠vel para an√°lise de multa leve');
        toast.warning('‚ö†Ô∏è CPF do propriet√°rio/cliente n√£o dispon√≠vel - an√°lise de multa leve n√£o realizada');
          }
          
        } catch (error: any) {
          console.error('‚ùå Erro na an√°lise de multa leve:', error);
          toast.error('‚ùå Erro na an√°lise de multa leve: ' + error.message);
        }
        
        console.log('‚úÖ === AN√ÅLISE DE MULTA LEVE CONCLU√çDA ===');
      }
      
      console.log('‚úÖ Multa salva automaticamente:', multaSalva);
      console.log('üÜî UUID da multa salva:', multaSalva?.id);
      
      if (!multaSalva?.id) {
        console.error('‚ùå ERRO: Multa salva mas sem ID v√°lido!');
        throw new Error('Multa salva mas sem ID v√°lido');
      }
      
      return multaSalva;
      
    } catch (error: any) {
      console.error('‚ùå Erro ao salvar multa automaticamente:', error);
      return null;
    }
  };
  
  const updateServiceOrderWithMultaId = async (serviceOrderId: string, multaId: string) => {
    try {
      console.log('üîó Atualizando service_orders com multa_id...');
      console.log('üìã Service Order ID:', serviceOrderId);
      console.log('üÜî Multa ID:', multaId);
      
      // Importar supabase client
      const { supabase } = await import('../lib/supabase');
      
      const { data, error } = await supabase
        .from('service_orders')
        .update({ multa_id: multaId })
        .eq('asaas_payment_id', serviceOrderId)
        .select();
      
      if (error) {
        console.error('‚ùå Erro ao atualizar service_orders:', error);
        throw error;
      }
      
      console.log('‚úÖ Service_orders atualizado com multa_id:', data);
      return data;
      
    } catch (error: any) {
      console.error('‚ùå Erro ao relacionar service_orders com multa:', error);
      return null;
    }
  };
  
  const handleSaveMulta = async () => {
    try {
      // Esta fun√ß√£o mant√©m a funcionalidade original para compatibilidade
      return await handleSaveMultaAutomatically(multaData);
    } catch (error: any) {
      console.error('‚ùå Erro ao salvar multa:', error);
      toast.error('Erro ao salvar multa: ' + error.message);
      throw error;
    }
  };

  const handleFinalize = async () => {
    // Salvar multa no banco de dados
    await handleSaveMulta();
    
    // Aqui tamb√©m poderia salvar o recurso gerado
    alert('Recurso finalizado e multa salva no banco de dados!');
  };

  return (
    <div className="min-h-screen bg-gray-50 p-6">
      <div className="max-w-6xl mx-auto">
        {/* Header */}
        <div className="bg-white rounded-lg shadow-sm p-6 mb-6">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">
            Teste - Recurso com IA
          </h1>
          <p className="text-gray-600">Sistema experimental para cria√ß√£o de recursos de multa com assist√™ncia de intelig√™ncia artificial</p>
          
          {/* Cabe√ßalho compacto de informa√ß√µes do cliente */}
          {clienteData && (clienteData.nome || clienteData.service_order_id) ? (
            <div className="mt-4 bg-blue-50 border border-blue-200 rounded-md p-3">
              <div className="flex items-center justify-between">
                <div className="flex items-center space-x-4">
                  <div className="flex items-center">
                    <User className="w-3 h-3 text-blue-600 mr-1" />
                    <span className="text-xs font-medium text-blue-900">Requerente:</span>
                  </div>
                  
                  {/* Informa√ß√µes principais em linha */}
                  <div className="flex items-center space-x-3 text-xs">
                    {clienteData.nome && (
                      <span className="text-gray-700 font-medium">{clienteData.nome}</span>
                    )}
                    
                    {clienteData.cpf_cnpj && (
                       <span className="text-gray-600">{clienteData.cpf_cnpj}</span>
                     )}
                    
                    {clienteData.service_order_id && (
                      <span className="text-blue-600 font-mono">{clienteData.service_order_id}</span>
                    )}
                  </div>
                </div>
                
                {/* Indicador de status */}
                <div className="text-xs text-green-600 flex items-center">
                  <div className="w-2 h-2 bg-green-500 rounded-full mr-1"></div>
                  Dados carregados
                </div>
              </div>
            </div>
          ) : (
            <div className="mt-4 bg-gray-50 border border-gray-200 rounded-md p-2">
              <div className="flex items-center text-gray-500 text-xs">
                <User className="w-3 h-3 mr-1" />
                <span>Nenhum dado de cliente carregado</span>
              </div>
            </div>
          )}
          
          {/* Progress Steps */}
          <div className="flex items-center mt-6 space-x-4">
            <div className={`flex items-center space-x-2 ${
              currentStep === 'upload' ? 'text-blue-600' :
                ['extraction', 'recurso'].includes(currentStep) ? 'text-green-600' : 'text-gray-400'
            }`}>
              <Upload className="w-5 h-5" />
              <span className="font-medium">Upload</span>
            </div>
            <div className="w-8 h-0.5 bg-gray-300"></div>
            <div className={`flex items-center space-x-2 ${
              currentStep === 'extraction' ? 'text-blue-600' :
                currentStep === 'recurso' ? 'text-green-600' : 'text-gray-400'
            }`}>
              <FileText className="w-5 h-5" />
              <span className="font-medium">Extra√ß√£o</span>
            </div>
            <div className="w-8 h-0.5 bg-gray-300"></div>
            <div className={`flex items-center space-x-2 ${
              'text-gray-400'
            }`}>
              <MessageCircle className="w-5 h-5" />
              <span className="font-medium">Chat IA</span>
            </div>
            <div className="w-8 h-0.5 bg-gray-300"></div>
            <div className={`flex items-center space-x-2 ${
              currentStep === 'recurso' ? 'text-blue-600' : 'text-gray-400'
            }`}>
              <Eye className="w-5 h-5" />
              <span className="font-medium">Recurso</span>
            </div>
          </div>
        </div>

        {/* Content Sections */}
        <div className="grid grid-cols-1 gap-6">
          {/* Se√ß√£o 1: Upload de Documento */}
          <div className="bg-white rounded-lg shadow-sm p-6">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-semibold text-gray-900 flex items-center">
                <Upload className="w-5 h-5 mr-2" />
                Upload de Documento
              </h2>
              
              {isProcessLocked && (
                <button
                  onClick={handleNewProcess}
                  className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm font-medium"
                >
                  Novo Recurso
                </button>
              )}
            </div>
            
            {isProcessLocked ? (
              <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center bg-gray-50">
                <div className="flex flex-col items-center space-y-4">
                  <div className="w-16 h-16 bg-green-100 rounded-full flex items-center justify-center">
                    <FileText className="w-8 h-8 text-green-600" />
                  </div>
                  <div>
                    <h3 className="text-lg font-medium text-gray-900 mb-2">Processo Protegido</h3>
                    <p className="text-gray-600 mb-2">
                      Os dados foram extra√≠dos com sucesso e o processo est√° salvo.
                    </p>
                    <p className="text-sm text-gray-500">
                      ID do Processo: <span className="font-mono bg-gray-200 px-2 py-1 rounded">{processId}</span>
                    </p>
                  </div>
                  <div className="flex items-center space-x-2 text-sm text-green-700">
                    <div className="w-2 h-2 bg-green-500 rounded-full"></div>
                    <span>Documento processado e protegido contra altera√ß√µes</span>
                  </div>
                </div>
              </div>
            ) : (
              <FileUpload
                onFileSelect={handleFileUpload}
                acceptedTypes={['.pdf', '.jpg', '.jpeg', '.png']}
                maxSize={10}
              />
            )}
          </div>

          {/* Se√ß√£o 2: Dados Extra√≠dos */}
          <div className="bg-white rounded-lg shadow-sm p-6">
            <h2 className="text-xl font-semibold text-gray-900 mb-4 flex items-center">
              <FileText className="w-5 h-5 mr-2" />
              Dados Extra√≠dos
            </h2>
            
            <DataExtraction
              data={multaData}
              onDataChange={setMultaData}
              onStartChat={() => {}} // Fun√ß√£o vazia j√° que o chat inicia automaticamente
              isLoading={isProcessing}
            />
            
            {/* Bot√£o para exibir advert√™ncia se dispon√≠vel */}
            {analiseMultaLeve?.advertencia.sugerirAdvertencia && !showAdvertencia && (
              <div className="mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-3">
                    <div className="p-2 bg-yellow-100 rounded-lg">
                      <FileText className="h-5 w-5 text-yellow-600" />
                    </div>
                    <div>
                      <h4 className="text-sm font-medium text-yellow-800">
                        Advert√™ncia por Escrito Sugerida
                      </h4>
                      <p className="text-sm text-yellow-700">
                        Esta multa leve √© eleg√≠vel para advert√™ncia por escrito
                      </p>
                    </div>
                  </div>
                  <button
                    onClick={() => setShowAdvertencia(true)}
                    className="px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 transition-colors text-sm font-medium"
                  >
                    Ver Advert√™ncia
                  </button>
                </div>
              </div>
            )}
          </div>
          
          {/* Se√ß√£o 2.5: Advert√™ncia por Escrito (quando aplic√°vel) */}
          {showAdvertencia && analiseMultaLeve?.advertencia.sugerirAdvertencia && (
            <div className="bg-white rounded-lg shadow-sm border-l-4 border-yellow-500">
              <AdvertenciaEscrita
                analiseMultaLeve={analiseMultaLeve}
                dadosMulta={{
                  nomeCondutor: multaData.nomeProprietario || clienteData?.nome || 'Propriet√°rio n√£o identificado',
                  cpfCondutor: multaData.cpfCnpjProprietario || clienteData?.cpf_cnpj || 'CPF n√£o informado',
                  dataInfracao: multaData.data || 'Data n√£o informada',
                  localInfracao: multaData.local || 'Local n√£o informado',
                  placaVeiculo: multaData.veiculo || 'Placa n√£o informada',
                  descricaoInfracao: multaData.infracao || 'Infra√ß√£o n√£o especificada',
                  codigoInfracao: multaData.codigoInfracao || 'C√≥digo n√£o informado',
                  numeroAuto: multaData.numero || 'N√∫mero n√£o informado',
                  orgaoAutuador: multaData.orgaoAutuador || '√ìrg√£o Autuador'
                }}
                onClose={() => setShowAdvertencia(false)}
              />
            </div>
          )}

          {/* Se√ß√£o 3: Chat com IA n8n */}
          <div className="bg-white rounded-lg shadow-sm p-6 h-[600px] flex flex-col">
            <h2 className="text-xl font-semibold text-gray-900 mb-4 flex items-center">
              <MessageCircle className="w-5 h-5 mr-2 text-blue-600" />
              Chat com IA
              {n8nChatActive && (
                <span className="ml-2 px-2 py-1 bg-green-100 text-green-800 text-xs rounded-full">
                  Ativo
                </span>
              )}
            </h2>
            
            <div className="flex-1">
              {n8nChatActive ? (
                <div className="h-full flex flex-col">
                  <div className="flex-1 overflow-y-auto space-y-4 p-4 bg-gray-50 rounded-lg mb-4 max-h-96">
                    {n8nChatMessages.map((message) => (
                      <div
                        key={message.id}
                        className={`flex ${
                          message.type === 'user' ? 'justify-end' : 'justify-start'
                        }`}
                      >
                        <div
                          className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg break-words overflow-wrap-anywhere ${
                            message.type === 'user'
                              ? 'bg-blue-600 text-white'
                              : 'bg-white text-gray-900 shadow-sm border'
                          }`}
                        >
                          <p className="text-sm break-words whitespace-pre-wrap">
                            {message.content.split('\n').map((line, index, array) => (
                              <span key={index}>
                                {line}
                                {index < array.length - 1 && <br />}
                              </span>
                            ))}
                          </p>
                          <p className="text-xs mt-1 opacity-70">
                            {message.timestamp.toLocaleTimeString()}
                          </p>
                        </div>
                      </div>
                    ))}
                    {isN8nLoading && (
                      <div className="flex justify-start">
                        <div className="bg-white text-gray-900 shadow-sm border px-4 py-2 rounded-lg">
                          <div className="flex items-center space-x-2">
                            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                            <span className="text-sm">IA est√° pensando...</span>
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                  
                  {/* Input para enviar mensagens */}
                  <div className="flex space-x-2">
                    <input
                      type="text"
                      value={n8nInputValue}
                      onChange={(e) => setN8nInputValue(e.target.value)}
                      onKeyPress={handleN8nKeyPress}
                      placeholder="Digite sua mensagem..."
                      className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                      disabled={isN8nLoading}
                    />
                    <button
                      onClick={() => sendN8nMessage(n8nInputValue)}
                      disabled={isN8nLoading || !n8nInputValue.trim()}
                      className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      Enviar
                    </button>
                  </div>
                  
                  <div className="mt-2 p-2 bg-blue-50 rounded-lg">
                    <p className="text-xs text-blue-800">
                      üí° Este chat est√° conectado ao sistema de IA para processamento avan√ßado.
                    </p>
                  </div>
                </div>
              ) : (
                <div className="text-center py-8">
                  <MessageCircle className="w-12 h-12 text-blue-400 mx-auto mb-4" />
                  <p className="text-gray-500">Complete a extra√ß√£o de dados para ativar o chat</p>
                </div>
              )}
            </div>
          </div>

          {/* Se√ß√£o 3.5: Recursos Gerados pelo n8n */}
          {(recursosGerados.length > 0 || chatSessionId || multaId) && (
            <div className="bg-white rounded-lg shadow-sm p-6">
              <RecursosGerados
                multaId={multaId || undefined}
                chatSessionId={chatSessionId || undefined}
                companyId={clienteData?.cliente_id}
                onRecursoSelect={(recurso) => {
                  console.log('üìã Recurso selecionado:', recurso);
                  toast.success(`Recurso "${recurso.titulo}" selecionado`);
                }}
              />
            </div>
          )}

          {/* Se√ß√£o 4: Recurso Gerado */}
          <div className="bg-white rounded-lg shadow-sm p-6">
            <h2 className="text-xl font-semibold text-gray-900 mb-4 flex items-center">
              <Eye className="w-5 h-5 mr-2" />
              Recurso Gerado
            </h2>
            
            <RecursoPreview
              multaData={multaData}
              chatHistory={n8nChatMessages}
              recursoText={recursoText}
              onRecursoChange={handleRecursoChange}
              onFinalize={handleFinalize}
            />
          </div>
        </div>
      </div>
      

    </div>
  );
};

export default TesteRecursoIA;